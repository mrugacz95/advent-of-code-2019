#!/usr/local/bin/sbcl --script
(defun get-file (filename)
  (with-open-file (stream filename)
    (loop for line = (read-line stream nil)
      while line
      collect (loop for c across line
      collect c))))
(defvar grid (get-file "~/advent-of-code/day_18/day_18.in"))
; (print grid)

(defun grid-at (y x)
  (nth x (nth y grid)))
(defun collect-neighbours (y x)
  (let ((result ()))
  (loop for dir in '((1 0) (-1 0) (0 1) (0 -1))
    do (let ((ypos (+ y (nth 0 dir)))
                  (xpos (+ x (nth 1 dir))))
                  (let ((cell (grid-at ypos xpos)))
                   (when (char/= cell #\#)
                    ; (print cell)
                    (push (list ypos xpos) result)))))
    ; (format t "result ~A" result)
    result))
(defun make-graph ()
  (let ((result ()))
  (loop for y from 0 below (list-length grid)
    do (let ((row (nth y grid)))
       (loop for x from 0 below (list-length row)
          do (let ((cell (nth x row)))
            (when (char/= cell #\#)
              (push (collect-neighbours y x) result))))))
  result))
; (format t "~A" (make-graph))
(defun is-in (elem l) (loop for e in l do (when (equal elem e) (return-from is-in t))) nil)
(defun calc-dist (from to)
  (let ((queue ())
        (visited ())
        (distance (list 0)))
    (push from queue)
    (loop while (not (null queue))
      do (let ((current (pop queue))
                (dist (pop distance)))
            ; (print queue)
            ; (print visited)
            ; (format t "vis: ~A" visited)(terpri)
            ; (print dist)
            ; (print current)
            (if (equal current to)
              (return-from calc-dist dist)
              (when (not (is-in current visited))
                ; (print "not visited")
                ; (print (second current))
                (let ((neighbours (collect-neighbours (first current) (second current))))
                  ; (print neighbours)
                  (setq distance (append distance (loop for n in neighbours
                    collect (1+ dist))))
                  (setq queue
                    (append queue neighbours)))))

          (push current visited)))))
; (print (calc-dist (list 1 6) (list 3 6)))
(defun is-lower (c) (eq (char-downcase c) c))
(defun is-upper (c) (eq (char-upcase c) c))
(defvar keys ())
(defun has-key (key)
  (return-from has-key (not (null (member key keys)))))
(defun can-pass (cell)
  (if (is-lower cell)
    (return-from can-pass t))
  (if (and (is-upper cell) (has-key (char-downcase cell)))
    (return-from can-pass t))
  nil)
(defun available-moves (pos)
  (let ((queue (list pos))
        (visited ())
        (available ()))
    ; (format t "queue: ~A" queue)(terpri)
    (loop while (not (null queue))
      do (let ((current (pop queue)))
              (push current visited) ; todo add visited in calc-dist
              ; (format t "current: ~A" current)(terpri)
              ; (format t "queue: ~A" queue)(terpri)
              ; (format t "visited: ~A" visited)(terpri)
              (loop for n in (collect-neighbours (first current) (second current))
                do (let ((cell (grid-at (first n) (second n))))
                  ; (format t "cell: ~A" cell)(terpri)
                  (when (and (not (is-in n visited)) (or (char= cell #\.) (char= cell #\@)))
                        ; (format t "n: ~A" n)(terpri)
                        (setq queue (append queue (list n))))
                  (when (and (char/= cell #\@)
                             (char/= cell #\.)
                             (can-pass cell))
                    ; (print "tutaj")
                    (push (list n cell) available))))

              ; (print queue)
              ))
      available))
; (print (available-moves (list 1 1)))
(defun find-entrance ()
  (loop for y from 0 below (list-length grid)
    do (let ((row (nth y grid)))
       (loop for x from 0 below (list-length row)
          do (let ((cell (nth x row)))
            (when (char= cell #\@)
              (return-from find-entrance (list y x))))))))
; (format t "~A" (find-entrance))
; (print grid)
(defun replace-at (y x value)
  (setf (nth x (nth y grid)) value))
; (replace-at 1 20 #\X)
; (print grid)
; (push #\d keys)
; (print keys)
; (print (has-key #\D))
; (print (can-pass #\d))
(defun print-grid ()
  (loop for row in grid
    do (loop for c in row
          do (format t "~a" c))
          (terpri))
  (terpri))
(defun compute-hash (pos)
  (let ((sum (+ (first pos) (* 53 (second pos))))
        (p 53)
        (count 2))
  (loop for row in grid
    do (loop for c in row
      do (setq sum (mod (+ sum (* (expt p count) (char-int c))) 100000007))
         (setq count (1+ count))))
  (loop for k in keys
    do (setq sum (mod (+ sum (* (expt p count) (char-int k))) 100000007))
       (setq count (1+ count)))
  sum))
(defvar cache (make-hash-table))
(defun count-moves (pos)
  ; (format t "call count-moves ~A" pos)
  (let ((hash (compute-hash pos)))
    (when (not (null (gethash hash cache)))
      ; (print "know answer")
      ; (print (gethash hash cache))
      (return-from count-moves (gethash hash cache)))
    (let ((c (grid-at (first pos) (second pos))))
      (when (is-lower c)
        (push c keys))
      (let ((available (available-moves pos))
            (min 1000000))
        (when (null available)
          (return-from count-moves 0))
        (replace-at (first pos) (second pos) #\.)
        ; (print available)
        ; (print keys)
        ; (print pos)
        ; (print-grid)
        (loop for move in available
          do (when (can-pass (second move))
            ; (format t "move: ~A" move)(terpri)
            (let ((dist (calc-dist pos (first move)))
                  (additional (count-moves (first move))))
              (when (< (+ dist additional) min)
                (setq min (+ dist additional))))))
        ; (format t "min: ~A" min)(terpri)
        (replace-at (first pos) (second pos) c)  ; revert previous state
        (when (is-lower c)
          (pop keys))
        (setf (gethash hash cache) min)
      min))))
(print (count-moves (find-entrance)))

; (print (compute-hash '(1 1)))
; (print (available-moves (find-entrance)))
