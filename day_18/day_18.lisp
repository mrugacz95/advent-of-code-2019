#!/usr/local/bin/sbcl --script
(defun get-file (filename)
  (with-open-file (stream filename)
    (loop for line = (read-line stream nil)
      while line
      collect (loop for c across line
      collect c))))
(defvar grid (get-file "~/advent-of-code/day_18/day_18.in"))
; (print grid)

(defun grid-at (y x)
  (nth x (nth y grid)))
(defun collect-neighbours (y x)
  (let ((result ()))
  (loop for dir in '((1 0) (-1 0) (0 1) (0 -1))
    do (let ((ypos (+ y (nth 0 dir)))
                  (xpos (+ x (nth 1 dir))))
                  (let ((cell (grid-at ypos xpos)))
                   (when (char/= cell #\#)
                    ; (print cell)
                    (push (list ypos xpos) result)))))
    ; (format t "result ~A" result)
    result))
(defun make-graph ()
  (let ((result ()))
  (loop for y from 0 below (list-length grid)
    do (let ((row (nth y grid)))
       (loop for x from 0 below (list-length row)
          do (let ((cell (nth x row)))
            (when (char/= cell #\#)
              (push (collect-neighbours y x) result))))))
  result))
; (format t "~A" (make-graph))
(defun is-in (elem l) (loop for e in l do (when (equal elem e) (return-from is-in t))) nil)
(defun calc-dist (from to)
  (let ((queue ())
        (visited ())
        (distance (list 0)))
    (push from queue)
    (loop while (not (null queue))
      do (let ((current (pop queue))
                (dist (pop distance)))
            ; (print queue)
            ; (print visited)
            ; (format t "vis: ~A" visited)(terpri)
            ; (print dist)
            ; (print current)
            (if (equal current to)
              (return-from calc-dist dist)
              (when (not (is-in current visited))
                ; (print "not visited")
                ; (print (second current))
                (let ((neighbours (collect-neighbours (first current) (second current))))
                  ; (print neighbours)
                  (setq distance (append distance (loop for n in neighbours
                    collect (1+ dist))))
                  (setq queue
                    (append queue neighbours)))))

          (push current visited)))))
; (print (calc-dist (list 1 6) (list 3 6)))
(defun is-lower (c) (eq (char-downcase c) c))
(defun is-upper (c) (eq (char-upcase c) c))
(defvar keys ())
(defun has-key (key)
  (return-from has-key (not (null (member key keys)))))
(defun can-pass (cell)
  (if (is-lower cell)
    (return-from can-pass t))
  (if (and (is-upper cell) (has-key (char-downcase cell)))
    (return-from can-pass t))
  nil)
(defun available-moves (pos)
  (let ((queue (list pos))
        (visited ())
        (available ()))
    ; (format t "queue: ~A" queue)(terpri)
    (loop while (not (null queue))
      do (let ((current (pop queue)))
              (push current visited) ; todo add visited in calc-dist
              ; (format t "current: ~A" current)(terpri)
              ; (format t "queue: ~A" queue)(terpri)
              ; (format t "visited: ~A" visited)(terpri)
              (loop for n in (collect-neighbours (first current) (second current))
                do (let ((cell (grid-at (first n) (second n))))
                  ; (format t "cell: ~A" cell)(terpri)
                  (when (not (is-in n visited))
                        (if (or (char= cell #\.) (char= cell #\@))
                          ; (format t "n: ~A" n)(terpri)
                          (setq queue (append queue (list n)))
                          (when (can-pass cell)
                            (push n visited)
                            (push (list n cell) available)))
                    ; (print "tutaj")
                    )))

              ; (print queue)
              ))
      (reverse available)))
; (print (available-moves (list 1 1)))
(defun find-entrance ()
  (loop for y from 0 below (list-length grid)
    do (let ((row (nth y grid)))
       (loop for x from 0 below (list-length row)
          do (let ((cell (nth x row)))
            (when (char= cell #\@)
              (return-from find-entrance (list y x))))))))
; (format t "~A" (find-entrance))
; (print grid)
(defun replace-at (y x value)
  (setf (nth x (nth y grid)) value))
; (replace-at 1 20 #\X)
; (print grid)
; (push #\d keys)
; (print keys)
; (print (has-key #\D))
; (print (can-pass #\d))
(defun print-grid ()
  (loop for row in grid
    do (loop for c in row
          do (format t "~a" c))
          (terpri))
  (terpri))
(defun compute-hash (pos)
  (let ((sum (+ (first pos) (* 53 (second pos))))
        (p 53)
        (count 2))
  (loop for k in (sort (copy-list keys) 'char<=)
    when (char/= k #\@)
    do (setq sum (mod (+ sum (* (expt p count) (char-int k))) 100000007))
       (setq count (1+ count)))
  sum))
(defvar cache (make-hash-table))
(defvar min_dist)
(setq min_dist 10000000000)

(defun search-symbols ()
  (let ((symbols ()))
    (loop for row in grid
      do (loop for c in row
        do (when (and (char/= c #\#) (char/= c #\.))
          (push c symbols))))
  symbols))
(defvar symbols (search-symbols))
(defun finished ()
  (eq (list-length keys) (/ (1- (list-length symbols)) 2)))
(defun find-position (symbol)
  (loop for y from 0 below (list-length grid)
    do (let ((row (nth y grid)))
       (loop for x from 0 below (list-length row)
          do (let ((cell (nth x row)))
            (when (char= cell symbol)
              (return-from find-position (list y x))))))))
(search-symbols)
; (print symbols)
; (print (find-position #\G))
; (print (find-position #\C))
; (print (calc-dist (find-position #\G) (find-position #\C)))
(defun precompute-distances ()
  (loop for s1 in symbols
    collect (loop for s2 in symbols
      collect (calc-dist (find-position s1)  (find-position s2)))))
(defvar distances (precompute-distances))
(defun get-dist (s1 s2)
  (nth (position s2 symbols) (nth (position s1 symbols) distances)))

; (print distances)
; (print (nth (position #\G symbols) distances))
; (print (list-length symbols))
; (print (get-dist #\G #\C))

(defvar tree (make-hash-table))
(defun dependency-tree ()
  (let ((queue (list (list (find-entrance) #\@)))
        (visited ()))
    (loop while (not (null queue))
      do (let ((popped (pop queue)))
           (let ((current (first popped))
                (c (grid-at (first (first popped))  (second (first popped)))))
              (let ((parent (if (char= c #\.)
                              (second popped)
                              c )))
                ; (format t "cur ~A par ~A" current parent)(terpri)
                (push current visited)
                (when (char/= c #\.)
                  ; (format t "~A ~A" c (second popped))(terpri)
                  (setf (gethash (second popped) tree) (append (gethash (second popped) tree) (list c)))
                  )
                (loop for n in (collect-neighbours (first current) (second current))
                  do (when (not (is-in n visited))
                       (setq queue (append queue (list (list n parent))))))))))))
; (print symbols)
(dependency-tree)
; (print tree)
(defun find-available ()
  (let ((available ())
        (queue (gethash #\@ tree)))
    (loop while (not (null queue))
            do (let ((current (pop queue)))
                (push current available)
                ; (print current)
                ; (print queue)
                (loop for child in (gethash current tree)
                  do
                  ; (format t "~A ~A" child current)(terpri)
                  (when (and (can-pass child)
                              (char/= child #\@)
                              (not (member child queue))
                              (or (not (null (member (char-downcase current) keys))) (not (null (member current keys)))))
                      ; (format t "add ~A" child)(terpri)
                          (setq queue (append queue (list child)))))))
  (loop for m in available
    when (and (is-lower m) (not (member m keys)) (char/= m #\@))
    collect m)))
; (push #\a keys)
; (push #\b keys)
; (push #\c keys)
; (print (find-available))
(defvar objects-pos (make-hash-table))
(defun collect-obj-pos ()
  (loop for s in symbols
    do (setf (gethash s objects-pos) (find-position s))))
(collect-obj-pos)
(defun find-available-moves ()
    (loop for c in (find-available)
      collect (list (gethash c objects-pos) c)))
; (print (find-available-moves))
; (print (compute-hash '(1 1)))
; (print (available-moves (find-entrance)))
(defvar cache (make-hash-table))
(defun count-moves (pos current_dist)
  ; (format t "call count-moves ~A" pos)
  (let ((hash (compute-hash pos)))
   (when (not (null (gethash hash cache)))
     ; (print "know answer")
     ; (print (gethash hash cache))
     (return-from count-moves (gethash hash cache))))
  (when (> current_dist min_dist)
    ; (print "too long, break")(terpri)
    (return-from count-moves min_dist))
  (let ((c (grid-at (first pos) (second pos))))
    (when (is-lower c)
      (push c keys))
    (let ((available (reverse (find-available-moves))))
      (when (null available)
        (when (is-lower c)
          (pop keys))
        ; (format t "finished in ~A moves" current_dist)(terpri)
        (when (< current_dist min_dist)
          ; (print keys)
          (format t "New champion: ~A" current_dist)(terpri)
          (setq min_dist current_dist))
        (return-from count-moves 0))
      ; (replace-at (first pos) (second pos) #\.)
      ; (print available)
      ; (print (reverse keys))
      ; (print pos)
      ; (print current_dist)(terpri)
      ; (print-grid)
      (let ((min_rest 1000000000))
        (loop for move in available
          do (when (can-pass (second move))
            ; (format t "move: ~A from: ~A to: ~A with history: ~A" move c (second move) keys)(terpri)
            (let ((dist (get-dist c (second move))))
              ; (format t "dist to make move: ~A" dist)(terpri)
              (let ((cur_min_rest (count-moves (first move) (+ dist current_dist))))
                (when (< (+ dist cur_min_rest) min_rest)
                  (setq min_rest (+ dist cur_min_rest)))))))
        ; (format t "min: ~A" min)(terpri)
        ; (replace-at (first pos) (second pos) c)  ; revert previous state
        (when (is-lower c)
          (pop keys))
        (let ((hash (compute-hash pos)))
          ; (format t "save  rest dist k:~A p:~A rest:~A" keys pos min_rest)(terpri)

          (setf (gethash hash cache) min_rest))
    min_rest))))
(format t "started walking")(terpri)
(format t "Answer: ~A" (count-moves (find-entrance) 0))
; (setq keys (list #\a #\b #\X #\c))
; (print (compute-hash (list 1 1)))
; (setq keys (list #\b #\X #\a #\c))
; (print (compute-hash (list 1 1)))
