#!/usr/local/bin/sbcl --script
(defun get-file (filename)
  (with-open-file (stream filename)
    (loop for line = (read-line stream nil)
      while line
      collect (loop for c across line
      collect c))))
(defvar grid (get-file "day_18.in"))
(defun grid-at (y x)
  (nth x (nth y grid)))
(defun collect-neighbours (y x)
  (let ((result ()))
  (loop for dir in '((1 0) (-1 0) (0 1) (0 -1))
    do (let ((ypos (+ y (nth 0 dir)))
                  (xpos (+ x (nth 1 dir))))
                  (let ((cell (grid-at ypos xpos)))
                   (when (char/= cell #\#)
                    (push (list ypos xpos) result)))))
    result))
(defun is-in (elem l) (loop for e in l do (when (equal elem e) (return-from is-in t))) nil)
(defun calc-dist (from to)
  (let ((queue ())
        (visited ())
        (distance (list 0)))
    (push from queue)
    (loop while (not (null queue))
      do (let ((current (pop queue))
                (dist (pop distance)))
            (if (equal current to)
              (return-from calc-dist dist)
              (when (not (is-in current visited))
                (let ((neighbours (collect-neighbours (first current) (second current))))
                  (setq distance (append distance (loop for n in neighbours
                    collect (1+ dist))))
                  (setq queue
                    (append queue neighbours)))))

          (push current visited)))))
(defun is-lower (c) (eq (char-downcase c) c))
(defun is-upper (c) (eq (char-upcase c) c))
(defvar keys (list #\1 #\2 #\3 #\4))
(defun has-key (key)
  (return-from has-key (not (null (member key keys)))))
(defun can-pass (cell)
  (if (is-lower cell)
    (return-from can-pass t))
  (if (and (is-upper cell) (has-key (char-downcase cell)))
    (return-from can-pass t))
  nil)
(defun find-entrance (c)
  (loop for y from 0 below (list-length grid)
    do (let ((row (nth y grid)))
       (loop for x from 0 below (list-length row)
          do (let ((cell (nth x row)))
            (when (char= cell c)
              (return-from find-entrance (list y x))))))))
(defun replace-at (y x value)
  (setf (nth x (nth y grid)) value))
(defun print-grid ()
  (loop for row in grid
    do (loop for c in row
          do (format t "~a" c))
          (terpri))
  (terpri))
(defun compute-hash (pos1 pos2 pos3 pos4)
  (return-from  compute-hash (format nil "~{~A,~}" (append pos1 pos2 pos3 pos4 (sort (copy-list keys) 'char<=))))
  (let ((sum 0)
        (p 53)
        (count 8))
  (setq sum (+ sum (* (expt p 0) (first pos2))))
  (setq sum (+ sum (* (expt p 1) (first pos2))))
  (setq sum (+ sum (* (expt p 2) (first pos2))))
  (setq sum (+ sum (* (expt p 3) (second pos2))))
  (setq sum (+ sum (* (expt p 4) (first pos3))))
  (setq sum (+ sum (* (expt p 5) (second pos3))))
  (setq sum (+ sum (* (expt p 6) (first pos4))))
  (setq sum (+ sum (* (expt p 7) (second pos4))))
  (loop for k in (sort (copy-list keys) 'char<=)
    when (and (char/= k #\1) (char/= k #\2) (char/= k #\3) (char/= k #\4))
    do (setq sum (+ sum (* (expt p count) (char-int k))))
       (setq count (1+ count)))
  sum))
(defvar min_dist 10000000000)
(defun search-symbols ()
  (let ((symbols ()))
    (loop for row in grid
      do (loop for c in row
        do (when (and (char/= c #\#) (char/= c #\.))
          (push c symbols))))
  symbols))
(defvar symbols)
(defun finished ()
  (eq (list-length keys) (/ (1- (list-length symbols)) 2)))
(defun find-position (symbol)
  (loop for y from 0 below (list-length grid)
    do (let ((row (nth y grid)))
       (loop for x from 0 below (list-length row)
          do (let ((cell (nth x row)))
            (when (char= cell symbol)
              (return-from find-position (list y x))))))))

(defun precompute-distances ()
  (loop for s1 in symbols
    collect (loop for s2 in symbols
      collect (calc-dist (find-position s1)  (find-position s2)))))
(defvar distances)
(defun get-dist (s1 s2)
  (nth (position s2 symbols) (nth (position s1 symbols) distances)))

(defvar tree (make-hash-table))
(defun dependency-tree ()
  (let ((queue (list (list (find-entrance #\1) #\1)
                      (list (find-entrance #\2) #\2)
                      (list (find-entrance #\3) #\3)
                      (list (find-entrance #\4) #\4)))
        (visited ()))
    (loop while (not (null queue))
      do (let ((popped (pop queue)))
           (let ((current (first popped))
                (c (grid-at (first (first popped))  (second (first popped)))))
              (let ((parent (if (char= c #\.)
                              (second popped)
                              c )))
                (push current visited)
                (when (and (char/= c #\.) (char/= c #\1) (char/= c #\2) (char/= c #\3) (char/= c #\4))
                  (setf (gethash (second popped) tree) (append (gethash (second popped) tree) (list c))))
                (loop for n in (collect-neighbours (first current) (second current))
                  do (when (not (is-in n visited))
                       (setq queue (append queue (list (list n parent))))))))))))
(defun find-available (start_char)
  (let ((available ())
        (queue (gethash start_char tree)))
    (loop while (not (null queue))
            do (let ((current (pop queue)))
                (push current available)
                (loop for child in (gethash current tree)
                  do
                  (when (and (can-pass child)
                              (char/= child #\4)
                              (char/= child #\3)
                              (char/= child #\2)
                              (char/= child #\1)
                              (not (member child queue))
                              (or (not (null (member (char-downcase current) keys))) (not (null (member current keys)))))
                          (setq queue (append queue (list child)))))))
  (loop for m in available
    when (and (is-lower m) (not (member m keys)) (char/= m #\@))
    collect m)))
(defvar objects-pos (make-hash-table))
(defun collect-obj-pos ()
  (loop for s in symbols
    do (setf (gethash s objects-pos) (find-position s))))
(defun find-available-moves (start_char)
    (loop for c in (find-available start_char)
      collect (list (gethash c objects-pos) c)))
(defvar cache (make-hash-table :test 'equal))

(defun count-moves (pos1 pos2 pos3 pos4 current_dist last_move)
  "pos1-4 - robot current positions, current_dist - distance walked from start"
  ; (format t "p1:~A p2:~A p3:~A p4:~A ~%" pos1 pos2 pos3 pos4)
  (let ((hash (compute-hash pos1 pos2 pos3 pos4))) ; computes current hash
   (when (not (null (gethash hash cache))) ; if hash already visited return immediately
     ; (format t "using cache: ~A ~A ~%" hash (gethash hash cache))
     (return-from count-moves (gethash hash cache))))
  (let ((c1 (grid-at (first pos1) (second pos1)))
        (c2 (grid-at (first pos2) (second pos2)))
        (c3 (grid-at (first pos3) (second pos3)))
        (c4 (grid-at (first pos4) (second pos4))))
    ; handle keys
    (when (and (is-lower c1) (eq last_move 0))
    ; (format t "1 grabs ~A ~%" c1)
      (push c1 keys))
    (when (and (is-lower c2) (eq last_move 1))
    ; (format t "2 grabs ~A ~%" c2)
      (push c2 keys))
    (when (and (is-lower c3) (eq last_move 2))
    ; (format t "3 grabs ~A ~%" c3)
      (push c3 keys))
    (when (and (is-lower c4) (eq last_move 3))
    ; (format t "4 grabs ~A ~%" c4)
      (push c4 keys))
    (let ((available (list (find-available-moves #\1) (find-available-moves #\2) (find-available-moves #\3) (find-available-moves #\4))))
      ; (format t "available ~A ~%" available)
      (when (every #'null available) ; no available moves
        ; (format t "No moves available ~%")
        (when (and (is-lower c1) (eq last_move 0))
          (pop keys))
        (when (and (is-lower c2) (eq last_move 1))
          (pop keys))
        (when (and (is-lower c3) (eq last_move 2))
          (pop keys))
        (when (and (is-lower c4) (eq last_move 3))
          (pop keys))
        (when (< current_dist min_dist)
          (format t "New champion: ~A ~%" current_dist)
          (format t "keys: ~A ~%" keys)
          (setq min_dist current_dist))
        (return-from count-moves 0))
      (let ((min_rest 1000000000)
            (characters (list c1 c2 c3 c4)))
      ; (format t "chars ~A ~%" characters)
      (loop for id in '(0 1 2 3)
        do
          ; (format t "id: ~A ~%" id)
          (loop for move in (nth id available)
          do (when (and (not (null move)) (can-pass (second move)))
            ; (format t "Doing ~A with id: ~A ~%" move id)
            (let ((dist (get-dist (nth id characters) (second move)))
                  (new_position (first move)))
              ; (format t "dist: ~A new_pos:~A ~%" dist new_position)
              (let ((cur_min_rest (count-moves
                                        (if (eq id 0) new_position pos1)
                                        (if (eq id 1) new_position pos2)
                                        (if (eq id 2) new_position pos3)
                                        (if (eq id 3) new_position pos4)
                                        (+ dist current_dist)
                                        id)))
                (when (< (+ dist cur_min_rest) min_rest)
                  (setq min_rest (+ dist cur_min_rest))))))))
        (when (and (is-lower c1) (eq last_move 0))
          (pop keys))
        (when (and (is-lower c2) (eq last_move 1))
          (pop keys))
        (when (and (is-lower c3) (eq last_move 2))
          (pop keys))
        (when (and (is-lower c4) (eq last_move 3))
          (pop keys))
        (let ((hash (compute-hash pos1 pos2 pos3 pos4)))
          ; (format t "newhash: ~A ~%" hash)
          (setf (gethash hash cache) min_rest))
    min_rest))))

(defun replace-middle () ; changes map into four separate sections
  (let ((y_min (1- (floor (list-length grid) 2)))
        (y_max (ceiling (list-length grid) 2))
        (x_min (1- (floor (list-length (nth 0 grid)) 2)))
        (x_max (ceiling (list-length (nth 0 grid)) 2)))
  (replace-at y_min x_min #\1)
  (replace-at y_min x_max #\2)
  (replace-at y_max x_min #\3)
  (replace-at y_max x_max #\4)
  (loop for y from  y_min to y_max
      do (replace-at y (floor (list-length (nth 0 grid)) 2) #\#))
  (loop for x from x_min to x_max
      do (replace-at (floor (list-length grid) 2) x #\#))))

(replace-middle)
(print-grid)
(setq symbols (search-symbols))
(setq distances (precompute-distances))
(format t "keys: ~A ~%" keys)
(format t "symbols: ~A ~%" symbols)
(format t "~A ~%" distances)
(dependency-tree)
(format t "dependecies~%")
(loop for key being the hash-keys of tree
        using (hash-value value)
        do (format t "~A: ~A~%" key value))
(collect-obj-pos)
(format t "objects pos~%")
(loop for key being the hash-keys of objects-pos
        using (hash-value value)
        do (format t "~A: ~A~%" key value))
(format t "started walking")(terpri)
(format t "Answer: ~A" (count-moves (find-entrance #\1)
                                    (find-entrance #\2)
                                    (find-entrance #\3)
                                    (find-entrance #\4)
                                    0
                                    nil))
